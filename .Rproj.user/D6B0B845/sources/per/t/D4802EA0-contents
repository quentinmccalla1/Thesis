---
editor_options: 
  markdown: 
    wrap: 72
---

# lab 02. More introduction to R. Booleans, flow control, functions

NOTES

Functional programming

-   "never repeat yourself", make the computer do the work for you

    simulates rolling a die

```{r}
dice <- function(ndice = 1){
  #simulate our dice roles
  diceroles <- sample.int(6, size = ndice, replace = TRUE)

#Sum dice roles
dicesum <- sum(diceroles)

#Spit the out put out to the user
return(dicesum)
}

```

Run the dice function

```{r}
#The number in the parenthesis correlates to the first parameter, nDice so 6 means ndice = 6
dice(6)
dice()
#Store output
ds <- dice(7)
```

Missing numbers

-   na means missing numbers

-   na.rm remove NAs = TRUE to remove

```{r}
x <- NA
y <- 7

x+y

mean(c(x,y), na.rm = TRUE)
```

Boolean

-   Trues and falses

-   You can use logic to combine multiple tests to complex queries

-   == means is equal to

-   \| \| means or

-   ! means not

```{r}
5 == 5 & 5>6& 5>4 #and logic
5 ==5 | 5>6    # or logic
! 5 >6  # not logic
```

```{r}
library(tidyverse)
 data <- read_csv("MonthlyGlobalTemperature.csv")
 
 years <-data[,1]
 which(years == 1956)
 
 #Combine logic
 test <- which(years >1930 & years < 1940)
 
 years$Year[(test)]
 
 #Mean temp in march
 mean(data$Mar[test])
```

Flow control

-   a set of commands that tell R how to move through your code

If/else/then statement

```{r}
if(5 ==5){
  print("Its true")
  
}else{print ("Its false")} 
```

Loops

-   While loop

Will run until it no longer passes a logical test

```{r}

t<- 0

while(t <10){
t <- t +1
print(t)
}
```

'break'

-   will break the loop

```{r}
t <- 0
while (TRUE) { 
  t <- t +2
  print(t)
  if(t >=20){break
    }
  
}

```

"For" loops

-   vector is a 1 D sequence of numbers

```{r}
for (i in 1:10) {
  print(i)
}




```

```{r}

temperature <- as.matrix(read_csv("MonthlyGlobalTemperature.csv"))
na.omit(temperature)


```

```{r}
for (col in 2:13) {
  
  #monthlymeans[col] <- print(mean(temperature[ ,col],na.rm = TRUE))
  
}
  

```

Other ways to repeat a function

```{r}
#library(tidyverse)
temperature <- read_csv("MonthlyGlobalTemperature.csv")
map(temperature,mean, na.rm= TRUE)


```

Custom function for a loop

```{r eval=FALSE, include=FALSE}
#specialmean <- function(tempvec){
 # subsetT <- tempvec[c1,5,9,13]
  #out <- mean(subsetT)
  #return(out)
  
}


#map(temperature,specialmean)
```

## lab 02 - part 1

To communicate effectively with your congressman, You need to convert a
bunch of temperatures from Celsius to Fahrenheit.

You could do this manually, using R like a calculator, but since you'll
be doing it a lot, why not make your life easier?

1a. Write a function that converts a temperature in Celsius to
Fahrenheit.
```{r}
Fer <- function(temperature){

fer <- (temperature[2:13])*9/5 + 32
  return(fer)
  
}
print(Fer(temperature
))
Ferenheight <- data.frame(Fer(temperature))

```


No year temp
```{r}
noyeartemp <- temperature[,-1]
```


1b. test it out, does it convert properly?

```{r}
#Test for Jan 1880
12.52*9/5 +32

#Worked! also double checked with google
```


1c. use your function to calculate the F equivalent of every C
temperature (only integers) between 0 and 100. You'll want to use seq()
for this.

```{r}
F100 <- seq(1,100, by = 1)


Fer100 <- function(temperature){

fer100 <- (F100)*9/5 + 32
  return(fer100)
  
}
Fer100 <- data.frame(Fer100(fer100))
Cel100 <- data.frame(F100)
```



1d. now make a scatter plot comparing C (x-axis) to F (y-axis) as
always, make reasonable axis labels and such

```{r}
length(Temp100$F100)
length(Temp100$Fer100.fer100.)



Temp100 <- data.frame(Celcius = Cel100, Fahrenheit = Fer100)

#Both columns are the same length bu it says that their lengths are different and wont plot

#plot(x = Temp100$F100., y = Temp100$Fer100.fer100. , xlab = "Celcius", ylab= "Fahrenheit")

plot(Temp100$F100)
plot(Temp100$Fer100.fer100.)



```



1e. What temperature is the same in C as in F? I know that you may
already know this, and it's much easier to solve algebraically, but I
want you to solve it the hard way. Specifically: write a while loop,
that uses your function to keep testing integers until you find the
answer. If I were you, I'd start with the smallest possible C (that's an
integer), and move up, to make sure you don't miss it. remember - be
careful with while loops, as they can make your computer keep running
forever.


```{r}


CeltoFer <- function(celsius){
  ferenheit <- (9/5 * celsius) +32
  return(ferenheit)
  
}
celsius <- -272


while(TRUE){
  ferenheit <- CeltoFer(celsius)
  if(celsius == ferenheit){
    print(paste("EQUAL", celsius, "C"))
    break
  }
  
celsius <- celsius +1
}

```


1f. Write a for loop that calculates Fahrenheit temperatures for the
following Celsius temperatures:

```{r}
Cels <- c(-10,17,25,0,45,-37,24,6,100,11,-18)

Q1f <- function(Cels){
  ferenheit1 <- (Cels* 9/5)+ 32
  
  return(ferenheit1)
  
}
print(Q1f(Cels))



```

1g. Now use the map function inside the purrr package (purrr::map) do
achieve the same result in one line of code.

```{r}
map(Cels,Q1f)


```


2.  OK, what if you wanted to make a more flexible function. You're
    going to create a function called `temperatureConverter`, which will
    be your one-stop shop for converting any temperature between F, C or
    K.

You're function is now going to need more inputs, right? Since you need
to know the temperature, what it's coming from, and what it's going to.
Ultimately, it should work if you type something like this:

`newTemp <- temperatureConverter(57,from="C",to="K")`

to make this work, you will need several if-else statements also, please
set up your function with default values of "C" for from, and "F" for
to.

demonstrate that your new function works by a. converting 300 K to C b.
converting 200 F to K c. converting 100 C to F with only one input
(taking advantage of your defaults)

```{r}

tempConverter <- function(temp, from = "C", to ="F"){
  
  # Conversion logic
  if (from == "C" && to == "F") {
    result <- (9/5 * temp) + 32
  } else if (from == "F" && to == "C") {
    result <- (5/9) * (temp - 32)
  } else if (from == "C" && to == "K") {
    result <- temp + 273.15
  } else if (from == "K" && to == "C") {
    result <- temp - 273.15
  } else if (from == "F" && to == "K") {
    result <- (5/9) * (temp - 32) + 273.15
  } else if (from == "K" && to == "F") {
    result <- (9/5) * (temp - 273.15) + 32
  } else if (from == to) {
    result <- temp  # If from and to units are the same, just return the temp
  }
  
  return(result)
}
  
tempConverter(300, from = "K", to = "C")
tempConverter(100, from = "C", to = "F")
tempConverter(200, from = "F", to = "K")


```



## Part 2. More functions and loops

Imagine this - we just took out our drones, and collected some fancy new
topography data for a volcano.

We loaded our data into R, and stored it in the variable "volcano" (this
is a built in dataset, it's already there. You can type
`volcano <- volcano` if you want to see it in your environment)
```{r}
volcano <- volcano
```


3a. what kind of data set is this?

```{r}
?volcano
#Topographic dataset

```


3b. what are it's dimensions?

this dataset is preloaded in R so you can learn more about it like this:

```{r}
?volcano
#Single dimension. It is just a list of numbers in different columns
```

3c. make a quick map of the volcano elevation using the "filled.contour"
plotting option

```{r}
filled.contour(volcano)
```


OK, we're interested in predicting where on the volcano is most likely
for landslides to occur to do this, we'd like to make a map of what the
slope is, everywhere on the volcano

4a. to do this, lets write a function, that calculates slope if you give
it a vector from the matrix (a vector being 1 column or row from the
matrix) (remember that slope is elevation change divided by horizontal
change)

`slope = function()`

so write a function that calculates change in elevation between grid
cells in a vector. The output should be all positive {use `abs()`} and
be 1 cell shorter than the input.
```{r}


Slope <- function(volcano){
  slope <- diff(volcano)
  absSlope <- abs(slope)
  
  return(absSlope)
}

print(Slope(volcano))

filled.contour(Slope(volcano))
```



4b. now use your function to calculate the slopes from the 43rd column
(a north-south stripe), and plot them (x=north-south,y=slope)

```{r}

Vol43 <- volcano[, 43]
Q4b <- Slope(Vol43)
NS <- 1:length(Q4b)

plot(x = NS, y = Q4b, type = "l", col = "blue", 
     xlab = "North-South Position", ylab = "Slope",
     main = "Slopes Along the 43rd Column (North-South)")

```


5a. now create a new matrix that's the appropriate size, full of NAs,
for your N-S slopes. use `matrix()` to do this.
```{r}
nrow(volcano) #87

NS_matrix <- matrix(NA, nrow= nrow(volcano)-1, ncol = ncol(volcano))

```


5b. now write a for loop that loops through all the columns, uses your
function to calculate the slopes, and then puts the values into your N-S
slopes matrix
```{r}
for (col in 1:ncol(volcano)) {
  elevation <- volcano[, col]
  
  slopes <- Slope(elevation)
  NS_matrix[1:(length(slopes)), col] <- slopes
  
}

```



5c. make a filled.contour plot of your N-S slopes

```{r}
filled.contour(
x1 <- 1:(nrow(volcano)-1),  # Rows of the volcano matrix (North-South direction)
y1 <- 1:(ncol(volcano)),  # Columns (East-West slopes are 1 shorter)

# z is the matrix of E-W slopes
z1 <- NS_matrix,  # Make sure this matrix has dimensions nrow(volcano) x (ncol(volcano) - 1)

# Check the dimensions of the matrix


# Use filled.contour to plot the E-W slopes
filled.contour(x = x1, y = y1, z = z1,
               color.palette = terrain.colors,
               xlab = "N-S Position",
               ylab = "E-W Position",
               main = "N-S Slope Map of the Volcano")
  
)
```



5d. write some code that tells us which cell has the greatest N-S slope

```{r}
max <- max((NS_matrix), na.rm = TRUE)
which(NS_matrix == max)
```


6.  repeat 5a-d for E-W

```{r}
ncol(volcano) #61

EW_matrix <- matrix(NA, nrow = nrow(volcano), ncol = ncol(volcano)-1)

for (row in 1:nrow(volcano)) {
  elevation <- volcano[row,]
  
  slopes <- Slope(elevation)
  
  EW_matrix[1:(length(slopes)), 1] <- slopes
  
EW_matrix[row, 1:length(slopes)] <- slopes
  
  }


```




```{r}

x <- 1:nrow(volcano) 
y <- 1:(ncol(volcano) - 1)
z <- EW_matrix  

filled.contour(x = x, y = y, z = z,
               color.palette = terrain.colors,
               xlab = "N-S Position",
               ylab = "E-W Position",
               main = "E-W Slope Map of the Volcano")
```


7a.Challenge question: Make a map that shows total slope on the volcano.
There are a few ways to do this, but the easiest is probably to average
your N-S slopes, and E-W slopes together. This is still a little tricky,
since your matrices are not the same size. How might you solve this and
get them on the same grid? It might help to sketch out a grid that shows
where you have elevations and where you have slopes (both NS and EW)


```{r}
# Assuming volcano is your matrix

# Initialize matrices for slopes
NS_matrix <- matrix(NA, nrow = nrow(volcano) - 1, ncol = ncol(volcano))
EW_matrix <- matrix(NA, nrow = nrow(volcano), ncol = ncol(volcano) - 1)

# Calculate N-S slopes (assuming Slope function is correct)
for (col in 1:ncol(volcano)) {
  elevation <- volcano[, col]
  slopes <- Slope(elevation)
  NS_matrix[1:length(slopes), col] <- slopes
}

# Calculate E-W slopes (assuming Slope function is correct)
for (row in 1:nrow(volcano)) {
  elevation <- volcano[row, ]
  slopes <- Slope(elevation)
  EW_matrix[row, 1:length(slopes)] <- slopes
}



# Pad NS_matrix and EW_matrix
padded_NS_matrix <- cbind(NS_matrix, rep(NA, nrow(NS_matrix))) # Add a column of NAs
padded_EW_matrix <- rbind(EW_matrix, rep(NA, ncol(EW_matrix))) # Add a row of NAs

# Check dimensions
print(dim(padded_NS_matrix))  # Should be (nrow(volcano) - 1, ncol(volcano))
print(dim(padded_EW_matrix))  # Should be (nrow(volcano), ncol(volcano) - 1)

# Combine slopes by averaging
total_slope <- matrix(NA, nrow = nrow(padded_EW_matrix), ncol = ncol(padded_EW_matrix))

# Populate the combined matrix
for (row in 1:nrow(total_slope)) {
  for (col in 1:ncol(total_slope)) {
    if (!is.na(padded_NS_matrix[row, col]) && !is.na(padded_EW_matrix[row, col])) {
      total_slope[row, col] <- sqrt(padded_NS_matrix[row, col]^2 + padded_EW_matrix[row, col]^2)
    }
  }
}

# Plot the total slope map
filled.contour(x = 1:ncol(total_slope), y = 1:nrow(total_slope), z = t(total_slope),
               color.palette = terrain.colors,
               xlab = "Column Position",
               ylab = "Row Position",
               main = "Total Slope Map of the Volcano")

```





```{r}
NS_matrix <- matrix(NA, nrow = nrow(volcano) - 1, ncol = ncol(volcano))
EW_matrix <- matrix(NA, nrow = nrow(volcano), ncol = ncol(volcano) - 1)

#NS Slopes
for (col in 1:ncol(volcano)) {
  elevation <- volcano[, col]
  slopes <- Slope(elevation)
  NS_matrix[1:length(slopes), col] <- slopes
}
#EW slopes
for (row in 1:nrow(volcano)) {
  elevation <- volcano[row, ]
  slopes <- Slope(elevation)
  EW_matrix[row, 1:length(slopes)] <- slopes
}

# Adjust dimensions to match
# Create padded matrices
padded_NS_matrix <- cbind(NS_matrix, rep(NA, nrow(NS_matrix))) # Add a column of NAs to match EW_matrix
padded_EW_matrix <- rbind(EW_matrix, rep(NA, ncol(EW_matrix))) # Add a row of NAs to match NS_matrix


# Create a matrix for combined slopes
total_slope <- matrix(NA, nrow = nrow(padded_EW_matrix), ncol = ncol(padded_EW_matrix))

# Populate the combined matrix
for (row in 1:nrow(total_slope)) {
  for (col in 1:ncol(total_slope)) {
    # Check if indices are within bounds
    if (row <= nrow(padded_NS_matrix) && col <= ncol(padded_NS_matrix)) {
      if (!is.na(padded_NS_matrix[row, col]) && !is.na(padded_EW_matrix[row, col])) {
        total_slope[row, col] <- sqrt(padded_NS_matrix[row, col]^2 + padded_EW_matrix[row, col]^2)
      }
    }
  }
}

# Plot the total slope map
filled.contour(x = 1:ncol(total_slope), y = 1:nrow(total_slope), z = t(total_slope),
               color.palette = terrain.colors,
               xlab = "Column Position",
               ylab = "Row Position",
               main = "Total Slope Map of the Volcano")

```

7b. make a final filled.contour plot that shows the average slope. Where
is the steepest part of the volcano?

```{r}
#The south-central to south eastern part of the volcano is the steepest.
```


