---
title: "lab02-nicks-notes"
author: "Nick"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#Week 02 - Functional programming, more on boolean, and flow control

## Welcome to RMarkdown!


## Coding philosophy: NEVER REPEAT YOURSELF!

### Functional Programming

The whole point here is to avoid repetition. A function is a piece of code that (usually) takes some number of inputs, and returns outputs. 

Here, we will create a function that simulates rolling a die.

You can create a function directly in your script, or RMarkdown

```{r}
dice <- function(nDice = 1){
  #simulate the dice roles
  diceRoles <- sample.int(6 , size = nDice, replace = TRUE)
  
  #now we want to sum these dice
  diceSum <- sum(diceRoles)
  
  #to get the result we want out, we need to "return" it
  
  return(diceSum)
  
}
```

now lets run our function

```{r}
dice(6)
```

An aside. All variables within a function, only exist inside that function. When something is returned, it is assigned into a variable of the users choosing, or printed. 


## Missing numbers

How does R handle missing numbers?

```{r}
x <- NA
y <- 7

is.na(x)
is.na(y)


```

## More on logic
use logic to learn about variables 

```{r}
is.data.frame(x)
is.logical(answer)

```

You can now use logic to combine multiple tests into more complex queries

```{r}
# & asks if both or all are TRUE
5==5 & 5 > 6 & 5 > 4 # AND statements

# | mean "or"
5==5 | 5 > 6 | 5 > 4 #OR STATEMENTS

#and you can combine them in creative ways to ask what you need to know

5==5 & (5 > 6 | 5 > 4)

#NOT statements
!FALSE


!5==5

#is x not a NA?
!is.na(x)


```


We can use logic in lots of ways in our code:

```{r}
data <- read.csv("MonthlyGlobalTemperature.csv")

year <- data[,1]
temperature <- data[ ,-1]

year == 1956

```
We can also combine logic to get ranges...

```{r}
year > 1900 & year <1920
```

What will happen if I change that `&` to a `|` ?



```{r}
year > 1900 | year <1920
```


the which() function returns the indices of a vector or matrix that are TRUE
```{r}
indicesIWant <- which(year > 1900 & year < 1920)
print(indicesIWant)
year[indicesIWant]

```

use that index intelligently:

```{r}
mean( temperature$Feb[indicesIWant])
```


One more example.

```{r}
#which february were less than -0.5?
temperature$Feb < -.5

coldFebruaries <- which(temperature$Feb < -.5)
print(coldFebruaries)

#How many Februaries met that criterion?
length(coldFebruaries)

#what were those temperature?
temperature$Feb[coldFebruaries]

#which years had those temperatures?
year[coldFebruaries]


```


### Flow Control
Flow control is a set of commands that lets you tell R how to move through your code. It uses booleans and logic to help make decisions


#### If/else/then statements

```{r}
if(5==5){
  print("It's TRUE!!!")
}else{
  print("It's FALSE!!!")
} 

```
#### While loops

While loops run until some logical test is false

```{r}
t <- 0

while(t<10){
  t <- t+1
  print(t)
}




```


#### the ''break'' command


```{r}
t <- 0

while(TRUE){
  t <- t+1
  
  print(t)
  
  if(t==15){
    break
  }
  
}




```

#### for loops

```{r}
for(i in 1:10){
  print(i)
}

animals <- c("ant","bear","cow","dog","elephant","fox")
for(j in animals){
  print(j)
}


#finally, the most common way that we use for loops, is with the vector being an index, and using i to refer to different subsets of dataset


for(i in 1:length(animals)){
  print(animals[i])
  
  
}

```

Lets load in our temperature data
```{r}
temperature <- read.csv("MonthlyGlobalTemperature.csv")
```

Let's go through each column, and calculate a mean

```{r}
for(i in 2:ncol(temperature)){
  print(mean(temperature[ ,i]))
}


```

We probably want to store the output somewhere


```{r}
for(i in 2:ncol(temperature)){
  monthlyMeans <- mean(temperature[ ,i])
}

```

Oh no, it's overwriting our values each time through the loop!

Lets add an index to monthly means to create a vector

```{r}
#we have to initialize our monthly means column
monthlyMeans2 <- c()

for(i in 2:ncol(temperature)){
  monthlyMeans2[i-1] <- mean(temperature[ ,i])
}
print(monthlyMeans2)
```

#for loops are great, but they're not the only way to repeat a function

install.packages("purrr")

```{r}
purrr::map(temperature,mean)
```

lets create a custom function

```{r}
cusFun <- function(x){
  out <- mean(x[c(1,4,7)])
  return(out)
}
```

now lets map our function to our data


```{r}
library(purrr)

map(temperature[,-1],cusFun)


```










































