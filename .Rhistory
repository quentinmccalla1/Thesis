slopes <- Slope(elevation)
EW_matrix[1:(length(slopes)), 1] <- slopes
}
EW_matrix[row, 1:length(slopes)] <- slopes
print(EW_matrix)
filled.contour(x= 87, y= 61, z = EW_matrix)
for (row in 1:nrow(volcano)) {
elevation <- volcano[row,]
slopes <- Slope(elevation)
EW_matrix[1:(length(slopes)), 1] <- slopes
}
for (row in 1:nrow(volcano)) {
elevation <- volcano[row,]
slopes <- Slope(elevation)
EW_matrix[1:(length(slopes)), 1] <- slopes
EW_matrix[row, 1:length(slopes)] <- slopes
}
View(EW_matrix)
# Assuming volcano is the original matrix and EW_matrix is your matrix of E-W slopes
# Define the x and y vectors
x <- 1:nrow(volcano)  # Rows of the volcano matrix (North-South direction)
y <- 1:(ncol(volcano) - 1)  # Columns (East-West slopes are 1 shorter)
# z is the matrix of E-W slopes
z <- EW_matrix  # Make sure this matrix has dimensions nrow(volcano) x (ncol(volcano) - 1)
# Check the dimensions of the matrix
print(dim(z))
# Use filled.contour to plot the E-W slopes
filled.contour(x = x, y = y, z = z,
color.palette = terrain.colors,
xlab = "North-South Position",
ylab = "East-West Position",
main = "E-W Slope Map of the Volcano")
for (col in 1:ncol(volcano)) {
elevation <- volcano[, col]
slopes <- Slope(elevation)
NS_matrix[1:(length(slopes)), 1] <- slopes
}
print(NS_matrix)
filled.contour(x= 87, y= 61, z = NS_matrix)
NS_matrix <- matrix(NA, nrow= nrow(volcano)-1, ncol = ncol(volcano))
for (col in 1:ncol(volcano)) {
elevation <- volcano[, col]
slopes <- Slope(elevation)
NS_matrix[1:(length(slopes)), 1] <- slopes
}
print(NS_matrix)
for (col in 1:ncol(volcano)) {
elevation <- volcano[, col]
slopes <- Slope(elevation)
NS_matrix[1:(length(slopes)), col] <- slopes
}
filled.contour(
x1 <- 1:nrow(volcano),  # Rows of the volcano matrix (North-South direction)
y1 <- 1:(ncol(volcano) - 1),  # Columns (East-West slopes are 1 shorter)
# z is the matrix of E-W slopes
z1 <- NS_matrix,  # Make sure this matrix has dimensions nrow(volcano) x (ncol(volcano) - 1)
# Check the dimensions of the matrix
# Use filled.contour to plot the E-W slopes
filled.contour(x = x1, y = y1, z = z1,
color.palette = terrain.colors,
xlab = "N-S Position",
ylab = "E-W Position",
main = "E-W Slope Map of the Volcano")
)
filled.contour(
x1 <- 1:nrow(volcano)-1,  # Rows of the volcano matrix (North-South direction)
y1 <- 1:(ncol(volcano)),  # Columns (East-West slopes are 1 shorter)
# z is the matrix of E-W slopes
z1 <- NS_matrix,  # Make sure this matrix has dimensions nrow(volcano) x (ncol(volcano) - 1)
# Check the dimensions of the matrix
# Use filled.contour to plot the E-W slopes
filled.contour(x = x1, y = y1, z = z1,
color.palette = terrain.colors,
xlab = "N-S Position",
ylab = "E-W Position",
main = "E-W Slope Map of the Volcano")
)
filled.contour(
x1 <- 1:(nrow(volcano)-1),  # Rows of the volcano matrix (North-South direction)
y1 <- 1:(ncol(volcano)),  # Columns (East-West slopes are 1 shorter)
# z is the matrix of E-W slopes
z1 <- NS_matrix,  # Make sure this matrix has dimensions nrow(volcano) x (ncol(volcano) - 1)
# Check the dimensions of the matrix
# Use filled.contour to plot the E-W slopes
filled.contour(x = x1, y = y1, z = z1,
color.palette = terrain.colors,
xlab = "N-S Position",
ylab = "E-W Position",
main = "E-W Slope Map of the Volcano")
)
filled.contour(
x1 <- 1:(nrow(volcano)-1),  # Rows of the volcano matrix (North-South direction)
y1 <- 1:(ncol(volcano)),  # Columns (East-West slopes are 1 shorter)
# z is the matrix of E-W slopes
z1 <- NS_matrix,  # Make sure this matrix has dimensions nrow(volcano) x (ncol(volcano) - 1)
# Check the dimensions of the matrix
# Use filled.contour to plot the E-W slopes
filled.contour(x = x1, y = y1, z = z1,
color.palette = terrain.colors,
xlab = "N-S Position",
ylab = "E-W Position",
main = "N-S Slope Map of the Volcano")
)
# Assuming volcano is your matrix
# Initialize matrices for slopes
NS_matrix <- matrix(NA, nrow = nrow(volcano) - 1, ncol = ncol(volcano))
EW_matrix <- matrix(NA, nrow = nrow(volcano), ncol = ncol(volcano) - 1)
# Calculate N-S slopes (assuming Slope function is correct)
for (col in 1:ncol(volcano)) {
elevation <- volcano[, col]
slopes <- Slope(elevation)
NS_matrix[1:length(slopes), col] <- slopes
}
# Calculate E-W slopes (assuming Slope function is correct)
for (row in 1:nrow(volcano)) {
elevation <- volcano[row, ]
slopes <- Slope(elevation)
EW_matrix[row, 1:length(slopes)] <- slopes
}
# Pad NS_matrix and EW_matrix
padded_NS_matrix <- cbind(NS_matrix, rep(NA, nrow(NS_matrix))) # Add a column of NAs
padded_EW_matrix <- rbind(EW_matrix, rep(NA, ncol(EW_matrix))) # Add a row of NAs
# Check dimensions
print(dim(padded_NS_matrix))  # Should be (nrow(volcano) - 1, ncol(volcano))
print(dim(padded_EW_matrix))  # Should be (nrow(volcano), ncol(volcano) - 1)
# Combine slopes by averaging
total_slope <- matrix(NA, nrow = nrow(padded_EW_matrix), ncol = ncol(padded_EW_matrix))
# Populate the combined matrix
for (row in 1:nrow(total_slope)) {
for (col in 1:ncol(total_slope)) {
if (!is.na(padded_NS_matrix[row, col]) && !is.na(padded_EW_matrix[row, col])) {
total_slope[row, col] <- sqrt(padded_NS_matrix[row, col]^2 + padded_EW_matrix[row, col]^2)
}
}
}
print(dim(padded_NS_matrix))  # Should be (nrow(volcano) - 1, ncol(volcano))
print(dim(padded_EW_matrix))
# Combine slopes by averaging
total_slope <- matrix(NA, nrow = nrow(padded_EW_matrix), ncol = ncol(padded_EW_matrix))
for (row in 1:nrow(total_slope)) {
for (col in 1:ncol(total_slope)) {
if (!is.na(padded_NS_matrix[row, col]) && !is.na(padded_EW_matrix[row, col])) {
total_slope[row, col] <- sqrt(padded_NS_matrix[row, col]^2 + padded_EW_matrix[row, col]^2)
}
}
}
# Assuming volcano is your matrix
# Initialize matrices for slopes
NS_matrix <- matrix(NA, nrow = nrow(volcano) - 1, ncol = ncol(volcano))
EW_matrix <- matrix(NA, nrow = nrow(volcano), ncol = ncol(volcano) - 1)
# Calculate N-S slopes (assuming Slope function is correct)
for (col in 1:ncol(volcano)) {
elevation <- volcano[, col]
slopes <- Slope(elevation)
NS_matrix[1:length(slopes), col] <- slopes
}
# Calculate E-W slopes (assuming Slope function is correct)
for (row in 1:nrow(volcano)) {
elevation <- volcano[row, ]
slopes <- Slope(elevation)
EW_matrix[row, 1:length(slopes)] <- slopes
}
# Pad NS_matrix and EW_matrix
padded_NS_matrix <- cbind(NS_matrix, rep(NA, nrow(NS_matrix))) # Add a column of NAs
padded_EW_matrix <- rbind(EW_matrix, rep(NA, ncol(EW_matrix))) # Add a row of NAs
# Check dimensions
print(dim(padded_NS_matrix))  # Should be (nrow(volcano) - 1, ncol(volcano))
print(dim(padded_EW_matrix))  # Should be (nrow(volcano), ncol(volcano) - 1)
# Combine slopes by averaging
total_slope <- matrix(NA, nrow = nrow(padded_EW_matrix), ncol = ncol(padded_EW_matrix))
# Populate the combined matrix
for (row in 1:nrow(total_slope)) {
for (col in 1:ncol(total_slope)) {
if (!is.na(padded_NS_matrix[row, col]) && !is.na(padded_EW_matrix[row, col])) {
total_slope[row, col] <- sqrt(padded_NS_matrix[row, col]^2 + padded_EW_matrix[row, col]^2)
}
}
}
# Initialize matrices for slopes
NS_matrix <- matrix(NA, nrow = nrow(volcano) - 1, ncol = ncol(volcano))
EW_matrix <- matrix(NA, nrow = nrow(volcano), ncol = ncol(volcano) - 1)
# Calculate N-S slopes
for (col in 1:ncol(volcano)) {
elevation <- volcano[, col]
slopes <- Slope(elevation)
NS_matrix[1:length(slopes), col] <- slopes
}
# Calculate E-W slopes
for (row in 1:nrow(volcano)) {
elevation <- volcano[row, ]
slopes <- Slope(elevation)
EW_matrix[row, 1:length(slopes)] <- slopes
}
# Adjust dimensions to match
# Create padded matrices
padded_NS_matrix <- cbind(NS_matrix, rep(NA, nrow(NS_matrix))) # Add a column of NAs to match EW_matrix
padded_EW_matrix <- rbind(EW_matrix, rep(NA, ncol(EW_matrix))) # Add a row of NAs to match NS_matrix
# Check dimensions
print(dim(padded_NS_matrix))  # Should be (nrow(volcano) - 1, ncol(volcano) + 1)
print(dim(padded_EW_matrix))  # Should be (nrow(volcano) + 1, ncol(volcano) - 1)
# Create a matrix for combined slopes
total_slope <- matrix(NA, nrow = nrow(padded_EW_matrix), ncol = ncol(padded_EW_matrix))
# Populate the combined matrix
for (row in 1:nrow(total_slope)) {
for (col in 1:ncol(total_slope)) {
# Check if indices are within bounds
if (row <= nrow(padded_NS_matrix) && col <= ncol(padded_NS_matrix)) {
if (!is.na(padded_NS_matrix[row, col]) && !is.na(padded_EW_matrix[row, col])) {
total_slope[row, col] <- sqrt(padded_NS_matrix[row, col]^2 + padded_EW_matrix[row, col]^2)
}
}
}
}
# Plot the total slope map
filled.contour(x = 1:ncol(total_slope), y = 1:nrow(total_slope), z = t(total_slope),
color.palette = terrain.colors,
xlab = "Column Position",
ylab = "Row Position",
main = "Total Slope Map of the Volcano")
length(Temp100$F100)
length(Temp100$Fer100.fer100.)
Temp100 <- data.frame(Celcius = Cel100, Fahrenheit = Fer100)
plot(x = Temp100$F100., y = Temp100$Fer100.fer100. , xlab = "Celcius", ylab= "Fahrenheit")
Temp100 <- data.frame(Celcius = Cel100, Fahrenheit = Fer100)
plot(x = Temp100$F100., y = Temp100$Fer100.fer100. , xlab = "Celcius", ylab= "Fahrenheit")
plot(x = Temp100$F100., y = Temp100$Fer100.fer100. , xlab = "Celcius", ylab= "Fahrenheit")
length(Temp100$F100)
length(Temp100$Fer100.fer100.)
Temp100_clean <- na.omit(Temp100)
plot(x = Temp100$F100., y = Temp100$Fer100.fer100. , xlab = "Celcius", ylab= "Fahrenheit")
plot(x = Temp100_clean$F100., y = Temp100$Fer100.fer100. , xlab = "Celcius", ylab= "Fahrenheit")
View(Temp100)
(x = Temp100_clean$F100., y = Temp100$Fer100.fer100. , xlab = "Celcius", ylab= "Fahrenheit")
plot(x = Temp100_clean$F100., y = Temp100$Fer100.fer100. , xlab = "Celcius", ylab= "Fahrenheit")
plot(Temp100)
plot(x = Temp100$F100., y = Temp100$Fer100.fer100. , xlab = "Celcius", ylab= "Fahrenheit")
plot(Temp100$F100)
plot(Temp100$Fer100.fer100.)
plot(Temp100$F100)
Temp100 <- data.frame(Celcius = Cel100, Fahrenheit = Fer100)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
#install.packages("ggplot2")
remove(HDR)
BRAP1row <- read_csv("BRAP1ROW.csv")
library(dplyr)
library(tidyverse)
#install.packages("ggplot2")
#remove(HDR)
BRAP1row <- read_csv("BRAP1ROW.csv")
Childs1row <- read_csv("Childs1ROW.csv")
BRAP1row <- na.omit(BRAP1row)
Childs1row <- na.omit(Childs1row)
#Diameter Beasley
((BeasleyMeans[3]-BeasleyMeans[1])/BeasleyMeans[1])*100
#Height and Diameter means
BeasleyMeans <- colMeans(BRAP1row)
ChildsMeans <-colMeans(Childs1row)
#Diameter Beasley
((BeasleyMeans[3]-BeasleyMeans[1])/BeasleyMeans[1])*100
#Height Beasley
((BeasleyMeans[4]-BeasleyMeans[2])/BeasleyMeans[2])*100
#print(ChildsMeans)
#Diamter Childs
((ChildsMeans[3]-ChildsMeans[1])/ChildsMeans[1])*100
#Height Childs
((ChildsMeans[4]-ChildsMeans[2])/ChildsMeans[2])*100
#Beasley 2023 HDR
# Define the function to calculate HDR (Height / Diameter)
HDR2023BRAP <- function(height, diameter) {
result <- height / diameter
return(result)
}
# Use mutate to add the new column, passing the correct columns to the function
BRAP1row <- BRAP1row %>%
mutate(HDR2023 = HDR2023BRAP(HeightBRAP2023, DiameterBRAP2024))
#Beasley 2024 HDR
HDR2024BRAP <- function(BRAP1row){
result <- BRAP1row$HeightBRAP2024 / BRAP1row$DiameterBRAP2024
}
# Use mutate to add the new column, passing the correct columns to the function
BRAP1row <- BRAP1row %>%
mutate(HDR2024 = HDR2023BRAP(HeightBRAP2024, DiameterBRAP2024))
#Childs 2023 HDR
HDR2023Childs <- function(height, diameter) {
result <- height / diameter
return(result)
}
Childs1row <- Childs1row %>%
mutate(HDR2023 = HDR2023Childs(HeightCHD.2023, DiameterCHD2022))
#Childs 2024 HDR
HDR2024Childs <- function(height, diameter) {
result <- height / diameter
return(result)
}
Childs1row <- Childs1row %>%
mutate(HDR2024 = HDR2023Childs(HeightCHD2024, DiameterCHD2023))
# Extract the columns you need
ChildsHDR2023 <- Childs1row[, 5]
ChildsHDR2024 <- Childs1row[, 6]
BRAPHDR2023 <- BRAP1row[,5]
BRAPHDR2024 <- BRAP1row[,6]
#Clean Data Childs
ChildsHDR2024 <- unlist(ChildsHDR2024)
ChildsHDR2024 <- na.omit(ChildsHDR2024)
ChildsHDR2023 <- unlist(ChildsHDR2023)
ChildsHDR2023<- na.omit(ChildsHDR2023
BRAPHDR2023 <- na.omit(BRAPHDR2023)
BRAPHDR2023 <- na.omit(BRAPHDR2023)
BRAPHDR2023 <- unlist(BRAPHDR2023)
BRAPHDR2024 <- na.omit(BRAPHDR2024)
BRAPHDR2024 <- unlist(BRAPHDR2024)
ChildsHDR2023<- na.omit(ChildsHDR2023
#Clean Data Childs
ChildsHDR2024 <- unlist(ChildsHDR2024)
ChildsHDR2024 <- na.omit(ChildsHDR2024)
ChildsHDR2023 <- unlist(ChildsHDR2023)
ChildsHDR2023<- na.omit(ChildsHDR2023
#Clean Data Childs
ChildsHDR2024 <- unlist(ChildsHDR2024)
ChildsHDR2024 <- unlist(ChildsHDR2024)
mean(BRAPHDR2023)
mean(BRAPHDR2024)
mean(ChildsHDR2023)
mean(ChildsHDR2024)
percentChange <- function( HDR2023, HDR2024){
result <- (HDR2023-HDR2024)/HDR2024 *100
return(result)
}
percentChange(108,90.7)
# Set up the plotting area to have 1 row and 2 columns
par(mfrow = c(1, 2)),
# Set up the plotting area to have 1 row and 2 columns
par(mfrow = c(1, 2))
# Create the first histogram
hist(BRAPHDR2023,
main = "Histogram of BRAPHDR2023",
xlab = "Values",
col = "lightblue",
breaks = "Sturges"),
# Set up the plotting area to have 1 row and 2 columns
par(mfrow = c(1, 2))
# Create the first histogram
hist(BRAPHDR2023,
main = "Histogram of BRAPHDR2023",
xlab = "Values",
col = "lightblue",
breaks = "Sturges")
# Create the second histogram
hist(BRAPHDR2024,
main = "Histogram of BRAPHDR2024",
xlab = "Values",
col = "lightgreen",
breaks = "Sturges")
# Reset plotting area to default
par(mfrow = c(1, 1))
# Set up the plotting area to have 1 row and 2 columns
par(mfrow = c(2, 2))
# Create the first histogram
hist(ChildsHDR2023,
main = "Histogram of Childs HDR 2023",
xlab = "Height to Diameter Ratio",
col = "grey",
breaks = "Sturges")
# Create the second histogram
hist(ChildsHDR2024,
main = "Histogram of Childs HDR 2024",
xlab = "Height to Diameter Ratio",
col = "grey",
breaks = "Sturges")
# Create the first histogram
hist(BRAPHDR2023,
main = "Histogram of BRAPHDR2023",
xlab = "Height to Diameter Ratio",
col = "grey22",
breaks = "Sturges")
# Create the second histogram
hist(BRAPHDR2024,
main = "Histogram of BRAPHDR2024",
xlab = "Height to Diameter Ratio",
col = "grey22",
breaks = "Sturges")
# Reset plotting area to default
par(mfrow = c(2, 2))
knitr::opts_chunk$set(echo = TRUE)
#install.packages("dplR")
#library(dplR)
Childs <- read.tucson("ChildsCol1.rwl")
#install.packages("dplR")
library(dplR)
knitr::opts_chunk$set(echo = TRUE)
#install.packages("dplR")
library(dplR)
Childs <- read.tucson("ChildsCol1.rwl")
Sheep <- read.tucson("SheepCol1.rwl")
UB <- read.tucson("UBCol1.rwl")
LB <- read.tucson("LBCol1.rwl")
summary.rwl(Childs)
ChildsRWI <- detrend( rwl = Childs, method = "AgeDepSpline")
ChildsRWI <- detrend( rwl = Childs, method = "AgeDepSpline")
#Childs
Chron.crn <- chron(ChildsRWI)
plot(Chron.crn, add.spline = TRUE, nyrs = 5)
BAI <- bai.in(Childs, d2pith= NULL)
BAI.rwi <- detrend(rwl= BAI, method = "AgeDepSpline")
BAIChron <- chron(BAI.rwi)
plot.crn(BAIChron, add.spline=TRUE, nyrs = 5, window(x=1980))
#XDatr/Cofecha
Childsseg <- corr.rwl.seg(Childs, seg.length = 6, pcrit= .1)
Sheepseg <- corr.rwl.seg(Sheep, seg.length = 6, pcrit = .1)
UBSeg <- corr.rwl.seg(UB, seg.length = 6,pcrit = .1)
LBSeg <-corr.rwl.seg(LB,seg.length = 6, pcrit = .1)
#Blue = well correlated to the master chronology
#Red = poorly correlated to the master chronology
#Green = not enough overlap
corr.series.seg(rwl = Childs, series = "C32", seg.length = 10)
ccf.series.rwl(rwl = Childs, series = "C32", seg.length = 10)
DendroMerge <- read_csv("DendroMergeforR.csv")
DendroMerge <- DendroMerge[,-8]
ggplot(DendroMerge, aes(x = PithHand, y = `Diameter (CM)`)) +
labs( x= "Pith Year", y = "Diameter (cm)", title = "Diameter vs Pith Date") +
geom_point(shape=18, size= 3)+
geom_smooth( method = "lm", se = FALSE, size = 1.5)+
scale_y_continuous(
limits = c(0,100)
) +
scale_x_continuous(
limits = c(1985,2020)
)
model <- lm(DendroMerge$`Diameter (CM)` ~ DendroMerge$PithHand, data = DendroMerge)
summary(model)
knitr::opts_chunk$set(echo = TRUE)
install.packages("dataRetrieval"
)
library(dataRetrieval)
readNWISdv(
"09506000",
parameterCd,
startDate = 1989/01/01,
endDate = "",
statCd = "00003"
)
readNWISdv(
"09506000",
00060,
startDate = 1989/01/01,
endDate = "",
statCd = "00003"
)
readNWISdv(
"09506000",
"00060",
startDate = 1989/01/01,
endDate = "",
statCd = "00003"
)
readNWISdv(
"09506000",
"00060",
startDate = "1989/01/01",
endDate = "",
statCd = "00003"
)
# Install the package (if you don't already have it)
install.packages("dataRetrieval")
# Load the package
library(dataRetrieval)
# Use the function as you showed
data <- readNWISdv(
"09506000",
"00060",
startDate = "1989/01/01",
endDate = "",
statCd = "00003"
)
knitr::opts_chunk$set(echo = TRUE)
# Use the function as you showed
data <- readNWISdv(
"09506000",
"00060",
startDate = "1989/01/01",
endDate = "",
statCd = "00003"
)
# Use the function as you showed
data <- readNWISdv(
"09506000",
"00060",
startDate = "1989/01/01",
endDate = "",
statCd = "00003"
)
# Use the function as you showed
<- readNWISdv(
# Use the function as you showed
readNWISdv(
"09506000",
"00060",
startDate = "1989/01/01",
endDate = "",
statCd = "00003"
)
install.packages("dataRetrieval"
)
library(dataRetrieval)
readNWISdv(
"09506000",
"00060",
startDate = "1989/01/01",
endDate = "",
statCd = "00003"
)
